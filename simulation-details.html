<!DOCTYPE html>
<html>
<head>
    <title>Utility Network Design</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            background: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow: auto;
            max-height: 500px;
        }
    </style>
</head>
<body>
    <h1>Utility Network Design - Full C++ Code</h1>
    <pre>
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct House {
    string id;
    double x, y;
    double pressure = 100.0; // Default pressure for each house
    vector&lt;pair&lt;string, double&gt;&gt; pipelines; // (connected house, cost)
};

// Function to calculate Euclidean distance between two houses
double calculateDistance(const House&amp; house1, const House&amp; house2) {
    return sqrt(pow(house2.x - house1.x, 2) + pow(house2.y - house1.y, 2));
}

// Adjust pressure within safe limits for the pipeline system
void adjustPressure(House&amp; house, double change) {
    house.pressure = max(20.0, min(100.0, house.pressure + change));
}

// BFS to traverse the utility network
void bfsTraversal(const unordered_map&lt;string, House&gt;&amp; network, const string&amp; startId) {
    queue&lt;string&gt; q;
    unordered_set&lt;string&gt; visited;

    q.push(startId);
    visited.insert(startId);

    while (!q.empty()) {
        string currentId = q.front();
        q.pop();

        cout &lt;&lt; "Visited: " &lt;&lt; currentId &lt;&lt; endl;
        for (const auto&amp; [neighborId, cost] : network.at(currentId).pipelines) {
            if (visited.find(neighborId) == visited.end()) {
                q.push(neighborId);
                visited.insert(neighborId);
            }
        }
    }
}

// DFS to traverse the utility network
void dfsTraversal(const unordered_map&lt;string, House&gt;&amp; network, const string&amp; startId, unordered_set&lt;string&gt;&amp; visited) {
    visited.insert(startId);
    cout &lt;&lt; "Visited: " &lt;&lt; startId &lt;&lt; endl;

    for (const auto&amp; [neighborId, cost] : network.at(startId).pipelines) {
        if (visited.find(neighborId) == visited.end()) {
            dfsTraversal(network, neighborId, visited);
        }
    }
}

// Kruskal's Algorithm to find Minimum Spanning Tree (MST)
struct Edge {
    string house1, house2;
    double cost;
};

bool compareEdges(const Edge&amp; e1, const Edge&amp; e2) {
    return e1.cost &lt; e2.cost;
}

string findParent(const string&amp; house, unordered_map&lt;string, string&gt;&amp; parent) {
    if (parent[house] != house) {
        parent[house] = findParent(parent[house], parent);
    }
    return parent[house];
}

void unionHouses(const string&amp; house1, const string&amp; house2, unordered_map&lt;string, string&gt;&amp; parent, unordered_map&lt;string, int&gt;&amp; rank) {
    string parent1 = findParent(house1, parent);
    string parent2 = findParent(house2, parent);

    if (parent1 != parent2) {
        if (rank[parent1] &gt; rank[parent2]) {
            parent[parent2] = parent1;
        } else if (rank[parent1] &lt; rank[parent2]) {
            parent[parent1] = parent2;
        } else {
            parent[parent2] = parent1;
            rank[parent1]++;
        }
    }
}

vector&lt;Edge&gt; kruskalMST(const vector&lt;Edge&gt;&amp; edges, const vector&lt;string&gt;&amp; houseIds) {
    vector&lt;Edge&gt; mst;
    unordered_map&lt;string, string&gt; parent;
    unordered_map&lt;string, int&gt; rank;

    for (const string&amp; house : houseIds) {
        parent[house] = house;
        rank[house] = 0;
    }

    vector&lt;Edge&gt; sortedEdges = edges;
    sort(sortedEdges.begin(), sortedEdges.end(), compareEdges);

    for (const Edge&amp; edge : sortedEdges) {
        if (findParent(edge.house1, parent) != findParent(edge.house2, parent)) {
            mst.push_back(edge);
            unionHouses(edge.house1, edge.house2, parent, rank);
        }
    }

    return mst;
}

int main() {
    // Create houses
    unordered_map&lt;string, House&gt; network = {
        {"H1", {"H1", 0, 0}},
        {"H2", {"H2", 1, 1}},
        {"H3", {"H3", 2, 2}},
        {"H4", {"H4", 3, 3}},
    };

    // Add pipelines
    network["H1"].pipelines.push_back({"H2", 1.5});
    network["H2"].pipelines.push_back({"H3", 2.0});
    network["H3"].pipelines.push_back({"H4", 2.5});
    network["H4"].pipelines.push_back({"H1", 3.0});

    // BFS traversal
    cout &lt;&lt; "BFS Traversal:\n";
    bfsTraversal(network, "H1");

    // DFS traversal
    cout &lt;&lt; "\nDFS Traversal:\n";
    unordered_set&lt;string&gt; visited;
    dfsTraversal(network, "H1", visited);

    // MST
    vector&lt;Edge&gt; edges = {
        {"H1", "H2", 1.5},
        {"H2", "H3", 2.0},
        {"H3", "H4", 2.5},
        {"H4", "H1", 3.0},
    };
    vector&lt;string&gt; houseIds = {"H1", "H2", "H3", "H4"};
    vector&lt;Edge&gt; mst = kruskalMST(edges, houseIds);

    cout &lt;&lt; "\nMinimum Spanning Tree:\n";
    for (const Edge&amp; edge : mst) {
        cout &lt;&lt; edge.house1 &lt;&lt; " - " &lt;&lt; edge.house2 &lt;&lt; ": " &lt;&lt; edge.cost &lt;&lt; endl;
    }

    return 0;
}
    </pre>
</body>
</html>
